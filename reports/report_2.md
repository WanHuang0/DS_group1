# Milestone 2

## Task 2
### 1. - What is a Hash function
While transferring a file from one computer to another it is often important to ensure that the copied file is the same as the source. One method one could use is called `hashing`, which is essentially a process that translates information about the file into a code. Two hash values (of the original file and its copy) can be compared to ensure the files are equal.

`Hash function` is an algorithm that calculates a fixed-size bit string value from a file.
A file basically contains blocks of data. `Hashing` transforms this data into a far shorter fixed-length value or key which represents the original string. The `hash value` can be considered the distilled summary of everything within that file.
A hash is usually a hexadecimal string of several characters. Hashing is also a unidirectional process so you can never work backwards to get back the original data.

A good `hash function` would exhibit a property called the avalanche effect, where the resulting hash output would change significantly or entirely even when a single bit or byte of data within a file is changed. A `hash functio`n that does not do this is considered to have poor randomization, which would be easy to break by hackers.
A good `hash function` should be complex enough such that it does not produce the same hash value from two different inputs. If it does, this is known as a hash collision. A `hash function` can only be considered good and acceptable if it can offer a very low chance of collision.

### 2. - What is a Python module, package and script? How do they differ from one another?
- A `Script` is a runnable Python programs that do something when executed.
Scripts will often contain code written outside the scope of any classes or functions. 
- A `Module` is a Python file that is intended to be imported into scripts and other modules. It often defines members like classes, functions, and variables intended to be used in other files that import it.
- A `Package` is a collection of related modules that work together to provide certain functionality. These modules are contained within a folder and can be imported just like any other modules. This folder will often contain a special __init__ file that tells Python it’s a package, potentially containing more modules nested within subfolders.

### 3. - How would you explain a Docker container and volume to a child?
Docker is a way to package application with all the necessay dependencies and configuration.
It is a portable artifact, easily shared and moved around. 
Docker volumes are file systems mounted on Docker containers to preserve data generated by the running container. 

To put it another way, imagine I build a house with all furnitures. 
One day I decide to travel around the world. I use a magical camera to take a photo of the house brfore I leave and put it in my backpack. 
Whenever I arrive at a new place, I just use this magical photo make a copy of house which I can directly move in.
I collect some materials along the journey and make handicrafts with the tools stored in the house. There is a problem with the house. Every time when I walk out of the house, 
the handicrafts will disappear. So I have to pack these stuff into my backpack and carry them with me. 
When I return to the house, I take out the stuff from my backpack and continue to make handicrafts.

### 4. - What is your preference concerning the use of Python virtualenv and Docker? When would you use one or the other?
**Python virtualenv**  
Python virtualenv allows users to switch between different versions and dependencies.
It is used to isolate projects. They also contain a reference to the python executable that should be used within the environment.
Normal use-cases include project isolation for local development and multiple independent Python projects on production.

**Docker**  
Docker encapsulates the application layer of operating system. It is used to isolate entire applications. 
It’s common to launch multiple Docker containers for different components of an application and communicating them over transfer channels.
Normal use-cases include shipping and running applications on production. 

The pros of using virtualenv over Docker include its ease of use (clean and simple interface), fast creation/activation of environments, 
lightweight environments and better developer experience for simple projects (for example IDE support).
In addition, Docker is a much more complex technology with limited support on Windows and MacOS.

The con of using virtualenv over Docker is that it’s support is limited to Python. By only using virtualenv, 
you have no guarantees that external dependencies in another system will play nicely with your code.
In comparison with virtualenv, Docker provides control over external dependencies, better reproducibility in different host systems, 
better control over all the components of an application (not just Python) and their interactions, reuse of common architectures (there are many Docker images online ready for use).


## Task 5
How to create a `pip "requirements file"` for the code base and get it work within a virtualenv.

Create a virutal environment (named `venv`) for Python with a separate interpreter:
```
python3 -m venv venv
```

To activate virtual environment, use the command `source`:
```
source venv/bin/activate
```

Having installed all the necessery packages using packet manager pip, 
we use command 
``` 
pip freeze 
```
to view currently installed packages.

To add packages use
```
pip install 
```

To create requirements file use
```
pip freeze > requirements.txt
```

We have created a `requirements.txt` file with requirements for the code.

To run the code on the new machine we have to pass over the python code
and the requirements file.

The virtual einvironment with dependencies can be set up by executing following commands:
```
python3 -m venv venv
source venv/bin/activate
pip install -r requirements.txt


## Task 6 Dockerize code
Steps:
1. Download and install Docker Desktop on windows 11
2. Open Docker Desktop, go to the settings and enable integration with defaut WSL distribution Ubuntu-22.04
3. Open Ubuntu terminal, go to the group project repository (root directory)
5. Use command `docker build . -t python3.9 -f build/Dockerfile` to create a new image named python3.9
6. Inspect docker images via command `docker images`
7. Use `docker run -v data:/var/lib/docker/volumes/  python3.9` to start a container with named volume  

## Optional project riddle
decode: https://www.docker.com/blog/wp-content/uploads/2019/10/2018-Halloween-2.jpg?ssl=1